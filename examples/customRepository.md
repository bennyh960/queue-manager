## Example: Custom Backend with PostgreSQL

You can use a custom backend to integrate with any data store, such as PostgreSQL.  
You are responsible for implementing atomic dequeue logic in your repository.  
The queue-manager will use your repository's methods and only check that the returned values are
valid.

### PostgreSQL Table Schema Example

Below is a minimal table definition for storing tasks in PostgreSQL.  
You can adjust column types and add indexes as needed for your use case.

```sql
-- Code Generated by Sidekick is for learning and experimentation purposes only.
CREATE TABLE tasks (
  id TEXT PRIMARY KEY,
  handler TEXT NOT NULL,
  payload JSONB NOT NULL,
  status TEXT NOT NULL, -- e.g., 'pending', 'processing', 'completed', 'failed'
  log JSONB,
  createdat TIMESTAMPTZ DEFAULT NOW(),
  updatedat TIMESTAMPTZ DEFAULT NOW(),
  maxretries INTEGER DEFAULT 3,
  maxprocessingtime INTEGER, -- milliseconds
  retrycount INTEGER DEFAULT 0,
  priority INTEGER DEFAULT 0
);

-- Optional: Indexes for performance
CREATE INDEX idx_tasks_status_priority ON tasks (status, priority DESC, createdat ASC);
```

Below is a minimal example using PostgreSQL and the `pg` npm package:

```typescript
import { Pool } from 'pg';
import { CustomQueueRepository, QueueManager } from 'queue-manager';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// Minimal implementation for PostgreSQL
const customRepo = new CustomQueueRepository({
  loadTasks: async () => {
    const { rows } = await pool.query('SELECT * FROM tasks ORDER BY id ASC');
    return rows;
  },
  saveTasks: async tasks => {
    // This is a simple approach: delete all and re-insert.
    // For production, use upserts or more efficient logic.
    await pool.query('DELETE FROM tasks');
    for (const task of tasks) {
      await pool.query(
        'INSERT INTO tasks (id, handler, payload, status, log, createdat, updatedat, maxretries, maxprocessingtime, retrycount, priority) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)',
        [
          task.id,
          task.handler,
          JSON.stringify(task.payload),
          task.status,
          task.log,
          task.createdAt,
          task.updatedAt,
          task.maxRetries,
          task.maxProcessingTime,
          task.retryCount,
          task.priority,
        ]
      );
    }
    return tasks;
  },
  dequeue: async () => {
    // Atomic dequeue: find the first pending task and mark as processing
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      const { rows } = await client.query(
        `SELECT * FROM tasks WHERE status = 'pending' ORDER BY priority DESC, createdat ASC LIMIT 1 FOR UPDATE SKIP LOCKED`
      );
      if (rows.length === 0) {
        await client.query('COMMIT');
        return null;
      }
      const task = rows[0];
      await client.query(
        `UPDATE tasks SET status = 'processing', updatedat = NOW() WHERE id = $1`,
        [task.id]
      );
      await client.query('COMMIT');
      return task;
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  },
});

const queue = QueueManager.getInstance<typeof handlers>({
  backend: { type: 'custom', repository: customRepo },
  processType: 'multi-atomic',
});
```
