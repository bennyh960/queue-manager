// Code Generated by Sidekick is for learning and experimentation purposes only.
/**
 * Minimal schema library with strong TS inference and autocompletion.
 */

type Literal = string | number | boolean | null;

type SchemaType = 'any' | 'string' | 'number' | 'boolean' | 'date' | 'literal' | 'enum' | 'array' | 'object' | 'union';

type Validator<T> = (val: T, path: (string | number)[]) => null | { path: (string | number)[]; message: string; details?: any };

interface MiniSchemaOptions {
  optional?: boolean;
  nullable?: boolean;
  default?: any;
  strict?: boolean;
}

export class ValidationError extends Error {
  errors: any[];
  constructor(errors: any[]) {
    super('Validation failed');
    this.errors = errors;
  }
}

export class MiniSchema<T> {
  type: SchemaType;
  validators: Validator<T>[];
  options: MiniSchemaOptions;
  children: any;

  constructor(type: SchemaType, opts: MiniSchemaOptions = {}) {
    this.type = type;
    this.validators = [];
    this.options = { ...opts };
    this.children = null;
  }

  static any() {
    const schema = new MiniSchema<any>('any');
    return schema;
  }

  static string() {
    const schema = new MiniSchema<string>('string');
    schema.validators.push((val, path) => (typeof val === 'string' ? null : { path, message: 'Expected string' }));
    return schema;
  }

  static number() {
    const schema = new MiniSchema<number>('number');
    schema.validators.push((val, path) => (typeof val === 'number' ? null : { path, message: 'Expected number' }));
    return schema;
  }

  static boolean() {
    const schema = new MiniSchema<boolean>('boolean');
    schema.validators.push((val, path) => (typeof val === 'boolean' ? null : { path, message: 'Expected boolean' }));
    return schema;
  }

  static date() {
    const schema = new MiniSchema<Date>('date');
    schema.validators.push((val, path) => (val instanceof Date && !isNaN(val as any) ? null : { path, message: 'Expected date' }));
    return schema;
  }

  static literal<V extends Literal>(value: V) {
    const schema = new MiniSchema<V>('literal');
    schema.validators.push((val, path) => (val === value ? null : { path, message: `Expected literal: ${value}` }));
    return schema;
  }

  static enum<V extends readonly [Literal, ...Literal[]]>(values: V) {
    const schema = new MiniSchema<V[number]>('enum');
    schema.validators.push((val, path) =>
      (values as readonly Literal[]).includes(val)
        ? null
        : { path, message: `Expected one of: ${(values as readonly Literal[]).join(', ')}` }
    );
    return schema;
  }

  static regex(regexp: RegExp, message = 'Invalid format') {
    const schema = MiniSchema.string();
    schema.validators.push((val, path) => (regexp.test(val) ? null : { path, message }));
    return schema;
  }

  static array<U>(childSchema: MiniSchema<U>) {
    const schema = new MiniSchema<U[]>('array');
    schema.children = childSchema;
    schema.validators.push((val, path) => {
      if (!Array.isArray(val)) return { path, message: 'Expected array' };
      return null;
    });
    return schema;
  }

  static objectAny() {
    const schema = new MiniSchema<Record<string, any>>('object');
    schema.validators.push((val, path) => {
      if (typeof val !== 'object' || val === null || Array.isArray(val)) {
        return { path, message: 'Expected object' };
      }
      return null;
    });
    // No children, so accepts any object shape
    schema.children = undefined;
    return schema;
  }

  static object<S extends { [k: string]: MiniSchema<any> }>(shape: S, opts: MiniSchemaOptions = {}) {
    // The mapped type below is the key for strong inference!
    type ObjType = { [K in keyof S]: TypeOf<S[K]> };
    const schema = new MiniSchema<ObjType>('object', opts);
    schema.children = shape;
    schema.validators.push((val, path) => {
      if (typeof val !== 'object' || val === null || Array.isArray(val)) {
        return { path, message: 'Expected object' };
      }
      return null;
    });
    return schema;
  }

  static union<S extends [MiniSchema<any>, ...MiniSchema<any>[]]>(schemas: S) {
    type UnionType = TypeOf<S[number]>;
    const schema = new MiniSchema<UnionType>('union');
    schema.children = schemas;
    schema.validators.push((val, path) => {
      const errors: any[] = [];
      for (const s of schemas) {
        const errs = s._validate(val, path, true);
        if (!errs.length) return null;
        errors.push(...errs);
      }
      return { path, message: 'No union type matched', details: errors };
    });
    return schema;
  }

  optional() {
    this.options.optional = true;
    (this as any).isOptional = true;
    return this as MiniSchema<T | undefined>;
  }

  nullable() {
    this.options.nullable = true;
    return this as MiniSchema<T | null>;
  }

  default(value: T) {
    this.options.default = value;
    return this as MiniSchema<T>;
  }

  refine(fn: (val: T) => boolean, message = 'Refinement failed') {
    this.validators.push((val, path) => (fn(val) ? null : { path, message }));
    return this;
  }

  deepOptional(): this {
    if (this.type === 'object') {
      (Object.values(this.children) as MiniSchema<any>[]).forEach((child: MiniSchema<any>) => child.deepOptional());
    }
    if (this.type === 'array') {
      this.children.deepOptional();
    }
    this.options.optional = true;
    return this;
  }

  deepRequired(): MiniSchema<any> {
    if (this.type === 'object') {
      (Object.values(this.children) as MiniSchema<any>[]).forEach((child: MiniSchema<any>) => child.deepRequired());
    }
    if (this.type === 'array') {
      this.children.deepRequired();
    }
    this.options.optional = false;
    return this;
  }

  private _validate(val: any, path: (string | number)[] = [], stopOnFirst = false): any[] {
    let errors: any[] = [];
    if (val === undefined) {
      if ('default' in this.options) return [];
      if (this.options.optional) return [];
      errors.push({ path, message: 'Missing required value' });
      if (stopOnFirst) return errors;
    } else if (val === null) {
      if (this.options.nullable) return [];
      errors.push({ path, message: 'Null not allowed' });
      if (stopOnFirst) return errors;
    } else {
      for (const validator of this.validators) {
        const err = validator(val, path);
        if (err) {
          errors.push(err);
          if (stopOnFirst) return errors;
        }
      }
      if (this.type === 'object' && typeof val === 'object' && val !== null && !Array.isArray(val) && this.children) {
        for (const [key, schema] of Object.entries(this.children) as [string, MiniSchema<any>][]) {
          const childVal = val[key];
          const childErrors = schema._validate(childVal, path.concat(key), stopOnFirst);
          errors.push(...childErrors);
          if (stopOnFirst && childErrors.length) return errors;
        }
        if (this.options.strict) {
          for (const key of Object.keys(val)) {
            if (!this.children[key]) {
              errors.push({ path: path.concat(key), message: 'Unknown key' });
              if (stopOnFirst) return errors;
            }
          }
        }
      }
      if (this.type === 'array' && Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          const childErrors = this.children._validate(val[i], path.concat(i), stopOnFirst);
          errors.push(...childErrors);
          if (stopOnFirst && childErrors.length) return errors;
        }
      }
    }
    return errors;
  }

  validateAll(val: Partial<T> | null | undefined): T {
    const errors = this._validate(val);
    if (errors.length) throw new ValidationError(errors);
    return this._applyDefaults(val);
  }

  validate(val: any): T {
    const errors = this._validate(val, [], true);
    if (errors.length) throw new ValidationError(errors);
    return this._applyDefaults(val);
  }

  _applyDefaults(val: any): any {
    if (val === undefined && 'default' in this.options) return this.options.default;
    if (this.type === 'object' && typeof val === 'object' && val !== null && !Array.isArray(val) && this.children) {
      const result: any = {};
      for (const [key, schema] of Object.entries(this.children) as [string, MiniSchema<any>][]) {
        result[key] = schema._applyDefaults(val[key]);
      }
      return result;
    }
    if (this.type === 'array' && Array.isArray(val)) {
      return val.map((v: any) => this.children._applyDefaults(v));
    }
    return val;
  }
}

// Type inference utility
export type TypeOf<S> = S extends MiniSchema<infer T> ? T : never;

// --- Example usage with strong inference ---

// --- Now you get autocompletion and type checking! ---
// const x: User = { email: "alice@example.com", birthday: null, tags: ["foo", "bar"], role: "admin" };

// type TaskSchemaBase = Omit<TypeOf<typeof TaskSchema>, 'handler' | 'payload'>;

// type TaskFromSchemaAndHandler<H extends HandlerMap> = {
//   [K in keyof H]: TaskSchemaBase & {
//     handler: K;
//     payload: Parameters<H[K]>[0];
//   };
// }[keyof H];

// export type Task<H extends HandlerMap> = TaskFromSchemaAndHandler<H>;

// example:
// import { MiniSchema as M } from './schema.util.js';

// export const TaskSchema = M.object({
//   id: M.string(),
//   handler: M.string(),
//   payload: M.objectAny(),
//   status: M.enum(['pending', 'processing', 'done', 'failed', 'deleted']),
//   log: M.string().default(''),
//   createdAt: M.union([M.date(), M.string()]).default(new Date()),
//   updatedAt: M.union([M.date(), M.string()]).default(new Date()),
//   maxRetries: M.number().default(10).optional(),
//   maxProcessingTime: M.number().default(5000),
//   retryCount: M.number().default(0),
//   priority: M.number().default(0),
// });
